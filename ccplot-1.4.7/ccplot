#!/usr/bin/env python
#
# ccplot
# This file is a part of ccplot: a CloudSat and CALIPSO plotting tool.
#
# Copyright (c) 2009, 2010 Peter Kuma
#
# This software is provided under the terms of a 2-clause BSD licence:
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#   1. Redistributions of source code must retain the above copyright notice,
#      this list of conditions and the following disclaimer.
#   2. Redistributions in binary form must reproduce the above copyright
#      notice, this list of conditions and the following disclaimer
#      in the documentation and/or other materials provided with
#      the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE CCPLOT PROJECT ``AS IS'' AND ANY EXPRESS
# OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
# OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
# IN NO EVENT SHALL THE CCPLOT PROJECT OR CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
# AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
# USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#

# We don't want the annoying KeyboadInterrupt exception on Control-C.
import signal
signal.signal(signal.SIGINT, signal.SIG_DFL)

#
# Includes.
#

# Core python includes.
import os
os.environ['PROJ_LIB']='/home/jhlee/anaconda3/envs/JUPYTER/share/proj'
import sys
from math import *
import getopt
import datetime as dt
import re

# Other includes.
import Nio
import numpy as np
import matplotlib as mpl
mpl.use("agg")
import matplotlib.pyplot as plt
from mpl_toolkits import basemap

# CCTK is a helper module that performs various calculations.
import cctk

# Early global variables.
program_name = os.path.basename(sys.argv[0])
__version__ = "1.4.7"
CCPLOT_CMAP_PATH = "/usr/share/ccplot/cmap:/usr/local/share/ccplot/cmap"

# Early functions.
def fail(s):
    global program_name
    print >> sys.stderr, "%s: %s" % (program_name, s)
    sys.exit(1)

# Version checking.
if mpl.__version__ < "0.98.1":
    fail("matplotlib 0.98.1 required, %s present" % mpl.__version__)
if basemap.__version__ < "0.99.4":
    fail("basemap 0.99.4 required, %s present" % basemap.__version__)
if np.__version__ < "1.1":
    fail("numpy 1.1 required, %s present" % np.__version__)
if Nio.__version__ < "1.3.0b1":
    fail("PyNIO 1.3.0b1 required, %s present" % Nio.__version__)


#
# Constants.
#

BAND_MODE_RAW = 0
BAND_MODE_REFLECTANCE = 1
BAND_MODE_RADIANCE = 2

PLANCK_C1 = 1.191E-16
PLANCK_C2 = 1.439E-2

ATRAIN_SPEED = 7.0 # km per s.
PROFILE_BINHEIGHT = 800 # Height of a bin in profile products in meters.
                        # This defines the area of influence of a data point.
EV_DATAPOINT_SIZE = 2000 # meters.

SUPPORTED_PROJECTIONS = ("aeqd","poly","gnom","moll","tmerc","nplaea","gall",
"mill","merc","stere","npstere","vandg","laea","mbtfpq","sinu","spstere",
"lcc","npaeqd","eqdc","cyl","aea","spaeqd","ortho","cass","splaea",
"robin")

# WORKAROUND: This array should be constant throughout CALIPSO data files.
# We list it inline here, because the field is stored in a VData structure
# that is not supported by PyNIO.
CALIPSO_HEIGHT = np.array((39.855106, 39.555317, 39.25553, 38.95574, 38.655952,
38.356167, 38.056377, 37.756588, 37.4568, 37.157013, 36.857224, 36.557434,
36.25765, 35.95786, 35.65807, 35.35828, 35.058495, 34.758705, 34.458916,
34.15913, 33.85934, 33.55955, 33.25976, 32.959976, 32.660187, 32.360397,
32.06061, 31.760822, 31.461033, 31.161245, 30.861456, 30.561668, 30.261879,
30.022049, 29.842176, 29.662304, 29.48243, 29.302557, 29.122684, 28.94281,
28.762938, 28.583065, 28.403193, 28.223318, 28.043446, 27.863573, 27.6837,
27.503826, 27.323954, 27.144081, 26.964209, 26.784334, 26.604462, 26.42459,
26.244717, 26.064842, 25.88497, 25.705097, 25.525225, 25.34535, 25.165478,
24.985605, 24.805733, 24.625858, 24.445986, 24.266113, 24.086239, 23.906366,
23.726494, 23.546621, 23.366747, 23.186874, 23.007002, 22.82713, 22.647255,
22.467382, 22.28751, 22.107637, 21.927763, 21.74789, 21.568018, 21.388145,
21.208271, 21.028399, 20.848526, 20.668653, 20.48878, 20.308907, 20.188992,
20.129034, 20.069077, 20.009119, 19.94916, 19.889202, 19.829245, 19.769287,
19.70933, 19.649372, 19.589415, 19.529457, 19.4695, 19.409542, 19.349585,
19.289627, 19.229668, 19.16971, 19.109753, 19.049795, 18.989838, 18.92988,
18.869923, 18.809965, 18.750008, 18.69005, 18.630093, 18.570133, 18.510176,
18.450218, 18.39026, 18.330303, 18.270346, 18.210388, 18.15043, 18.090473,
18.030516, 17.970558, 17.9106, 17.850641, 17.790684, 17.730726, 17.670769,
17.610811, 17.550854, 17.490896, 17.430939, 17.370981, 17.311024, 17.251066,
17.191107, 17.13115, 17.071192, 17.011234, 16.951277, 16.89132, 16.831362,
16.771404, 16.711447, 16.65149, 16.591532, 16.531574, 16.471615, 16.411657,
16.3517, 16.291742, 16.231785, 16.171827, 16.11187, 16.051912, 15.991955,
15.931996, 15.872039, 15.812081, 15.752124, 15.692166, 15.632208, 15.57225,
15.512293, 15.452335, 15.392378, 15.33242, 15.272462, 15.212504, 15.152547,
15.092589, 15.032632, 14.972674, 14.912716, 14.852758, 14.792801, 14.732843,
14.672886, 14.612928, 14.55297, 14.493012, 14.433055, 14.373097, 14.31314,
14.253181, 14.193224, 14.133266, 14.073309, 14.013351, 13.953394, 13.8934355,
13.833478, 13.77352, 13.713563, 13.653605, 13.593648, 13.5336895, 13.473732,
13.4137745, 13.353817, 13.2938595, 13.233902, 13.1739435, 13.113986, 13.0540285,
12.994071, 12.9341135, 12.874156, 12.814198, 12.75424, 12.694283, 12.634325,
12.574368, 12.514409, 12.454452, 12.394494, 12.334537, 12.274579, 12.214622,
12.154663, 12.094706, 12.034748, 11.974791, 11.914833, 11.854876, 11.794917,
11.73496, 11.675002, 11.615045, 11.555087, 11.49513, 11.435171, 11.375214,
11.315256, 11.255299, 11.195341, 11.135383, 11.075425, 11.015468, 10.95551,
10.895553, 10.835595, 10.775637, 10.715679, 10.655722, 10.595764, 10.535807,
10.475849, 10.415891, 10.355933, 10.295976, 10.236018, 10.176061, 10.116103,
10.056145, 9.996187, 9.93623, 9.876272, 9.816315, 9.756356, 9.696399, 9.636441,
9.576484, 9.516526, 9.456569, 9.39661, 9.336653, 9.276695, 9.216738, 9.15678,
9.096823, 9.036864, 8.976907, 8.916949, 8.856992, 8.797034, 8.737077, 8.677118,
8.617161, 8.557203, 8.497246, 8.437288, 8.37733, 8.317372, 8.257415, 8.212447,
8.182467, 8.152489, 8.12251, 8.092531, 8.062552, 8.032574, 8.002595, 7.972616,
7.942637, 7.912658, 7.8826795, 7.8527007, 7.822722, 7.792743, 7.762764,
7.732785, 7.7028065, 7.6728277, 7.642849, 7.61287, 7.582891, 7.552912,
7.5229335, 7.4929547, 7.462976, 7.432997, 7.403018, 7.3730392, 7.3430605,
7.3130817, 7.283103, 7.2531238, 7.223145, 7.1931663, 7.1631875, 7.1332088,
7.10323, 7.073251, 7.043272, 7.0132933, 6.9833145, 6.953336, 6.923357,
6.893378, 6.863399, 6.8334203, 6.8034415, 6.773463, 6.743484, 6.713505,
6.683526, 6.6535473, 6.6235685, 6.59359, 6.5636106, 6.533632, 6.503653,
6.4736743, 6.4436955, 6.413717, 6.3837376, 6.353759, 6.32378, 6.2938013,
6.2638226, 6.233844, 6.2038646, 6.173886, 6.143907, 6.1139283, 6.0839496,
6.053971, 6.0239916, 5.994013, 5.964034, 5.9340553, 5.9040766, 5.874098,
5.8441186, 5.81414, 5.784161, 5.7541823, 5.7242036, 5.6942244, 5.6642456,
5.634267, 5.604288, 5.5743093, 5.5443306, 5.5143514, 5.4843726, 5.454394,
5.424415, 5.3944364, 5.3644576, 5.3344784, 5.3044996, 5.274521, 5.244542,
5.2145634, 5.1845846, 5.1546054, 5.1246266, 5.094648, 5.064669, 5.0346904,
5.004711, 4.9747324, 4.9447536, 4.914775, 4.884796, 4.8548174, 4.824838,
4.7948594, 4.7648807, 4.734902, 4.704923, 4.6749444, 4.644965, 4.6149864,
4.5850077, 4.555029, 4.52505, 4.4950714, 4.465092, 4.4351134, 4.4051347,
4.375156, 4.345177, 4.315198, 4.285219, 4.2552404, 4.2252617, 4.195283,
4.165304, 4.135325, 4.105346, 4.0753675, 4.0453887, 4.01541, 3.985431,
3.9554522, 3.9254732, 3.8954945, 3.8655157, 3.8355367, 3.805558, 3.7755792,
3.7456002, 3.7156215, 3.6856427, 3.6556637, 3.625685, 3.5957062, 3.5657272,
3.5357485, 3.5057697, 3.4757907, 3.445812, 3.4158332, 3.3858542, 3.3558755,
3.3258967, 3.2959177, 3.265939, 3.23596, 3.2059813, 3.1760025, 3.1460235,
3.1160448, 3.086066, 3.056087, 3.0261083, 2.9961295, 2.9661505, 2.9361718,
2.906193, 2.876214, 2.8462353, 2.8162565, 2.7862775, 2.7562988, 2.72632,
2.696341, 2.6663623, 2.6363835, 2.6064045, 2.5764258, 2.546447, 2.516468,
2.4864893, 2.4565103, 2.4265316, 2.3965528, 2.3665738, 2.336595, 2.3066163,
2.2766373, 2.2466586, 2.2166798, 2.1867008, 2.156722, 2.1267433, 2.0967643,
2.0667856, 2.0368068, 2.0068278, 1.9768491, 1.9468702, 1.9168913, 1.8869126,
1.8569337, 1.8269548, 1.7969761, 1.7669972, 1.7370183, 1.7070396, 1.6770607,
1.6470819, 1.6171031, 1.5871242, 1.5571454, 1.5271665, 1.4971877, 1.4672089,
1.43723, 1.4072512, 1.3772724, 1.3472935, 1.3173147, 1.2873359, 1.257357,
1.2273781, 1.1973994, 1.1674205, 1.1374416, 1.1074629, 1.077484, 1.0475051,
1.0175264, 0.9875475, 0.95756865, 0.92758983, 0.897611, 0.86763215, 0.83765334,
0.8076745, 0.77769566, 0.74771684, 0.717738, 0.68775916, 0.65778035, 0.6278015,
0.59782267, 0.5678438, 0.537865, 0.5078862, 0.47790733, 0.4479285, 0.41794965,
0.3879708, 0.35799196, 0.32801315, 0.2980343, 0.26805547, 0.23807664, 0.2080978,
0.17811897, 0.14814013, 0.1181613, 0.088182464, 0.058203626, 0.028224792,
-0.001754042, -0.031732876, -0.06171171, -0.09169055, -0.12166938, -0.15164822,
-0.18162705, -0.21160589, -0.24158472, -0.27156356, -0.3015424, -0.3315212,
-0.36150005, -0.3914789, -0.42145774, -0.45143658, -0.61632013, -0.9161085,
-1.2158968, -1.5156852, -1.8154736), dtype=np.float32)
CALIPSO_HEIGHT = CALIPSO_HEIGHT[::-1]*1000 # meters

MODIS_WAVELENGTHS = np.zeros(36)
MODIS_WAVELENGTHS[0:36] = (645,858.500,469,555,1240,1640,2130,412.5,443,488,531,551,
667,678,748,869.500,905,936,940,
3660,3929,3929,4020,4433,4482,1360,6535,7175,8400,9580,10780,11770,13185,13485,
13785,14085)


#
# Global variables.
#

verbose = False

#
# Classes.
#

class Swath(object):
    name = ""
    lon = np.empty(0, dtype=np.float)
    lat = np.empty(0, dtype=np.float)
    data = np.empty(0, dtype=np.float)


class AutoOpts(object):
    def setint(self, o, v, a=-sys.maxint-1, b=sys.maxint):
        i = int(v)
        if i < a or i > b:
            raise ValueError("%s expected between %d and %d" % (o, a, b))
        return i

    def setfloat(self, o, v, a=float("-infinity"), b=float("infinity")):
        f = float(v)
        if f < a or f > b:
            raise ValueError("%s expected between %f and %f" % (o, a, b))
        return f
        
    def setstr(self, o, v, maxlen=sys.maxint):
        if len(v) > maxlen:
            raise ValueError("%s can be at most %d characters long" % (o, maxlen))
        return v

    def setcolor(self, o, v):
        if re.match("^#[0-9A-Z]{6}$", v, re.IGNORECASE) == None:
            raise ValueError("%s is not a valid color" % v)
        return v

    def settuple(self, o, v, func, *args, **kwargs):
        parts = v.split(":")
        return [func(o, p, *args, **kwargs) for p in parts]

    def setenum(self, o, v, vals):
        if v not in vals: raise ValueError("%s must be one of: %s" % (v,vals))
        return v

    def setbool(self, o, v):
        if v == "1": return True
        elif v == "0": return False
        else: raise ValueError("%s must be 1 or 0" % o)
        
    def setlon(self, o, v):
        if v.endswith("W"): lon -float(v[0:-1])
        elif v.endswith("E"): lon = float(v[0:-1])
        else: raise ValueError("%s must end with W or E" % o)
        if lon < -180 or lon > 180: raise ValueError("%s out of range" % o)
        return lon
    
    def setlat(self, o, v):
        if v.endswith("S"): lat = -float(v[0:-1])
        elif v.endswith("N"): lat = float(v[0:-1])
        else: raise ValueError("%s must end with S or N" % o)
        if lat < -90 or lat > 90: raise ValueError("%s out of range" % o)
        return lat
        

class PlotOpts(AutoOpts):
    cbfontsize = 8
    cbspacing = 0.4
    coastlinescolor = "#46396D"
    coastlineslw = 0.4
    countriescolor = "#46396D"
    countrieslw = 0.2
    drawcoastlines = True
    drawcountries = True
    drawelev = True
    drawlakes = True
    drawlsmask = True
    drawmeridians = True
    drawminormeridians = True
    drawminorparallels = True
    drawparallels = True
    elevcolor = "#FF0000"
    elevlw = 0.5
    fontsize = 10
    landcolor = "#E9E4F7"
    majormeridianscolor = "#000000"
    majormeridianslw = 0.3
    majorparallelscolor = "#000000"
    majorparallelslw = 0.3
    mapres = "i"
    meridiansbase = 0
    minormeridianscolor = "#000000"
    minormeridianslw = 0.1
    minorparallelscolor = "#000000"
    minorparallelslw = 0.1
    nminormeridians = 0
    nminorparallels = 0
    padding = 1.0
    parallelsbase = 0
    plotheight = 6.0
    title = None
    trajcolors = ("#FF0000", "#0000FF", "#00FF00")
    trajlws = (0.5,)
    trajticks = -1
    trajnminorticks = -1
    watercolor = "#FFFFFF"

    def setopt(self, o, v):
        if   o == "cbfontsize": q = self.setfloat(o, v, 0)
        elif o == "cbspacing": q = self.setfloat(o, v, 0)
        elif o == "coastlinecolor": q = self.setcolor(o, v)
        elif o == "coastlinelw": q = self.setfloat(o, v, 0)
        elif o == "countriescolor": q = self.setcolor(o, v)
        elif o == "countrieslw": q = self.setfloat(o, v, 0)
        elif o == "drawcoastlines": q = self.setbool(o, v)
        elif o == "drawcountries": q = self.setbool(o, v)
        elif o == "drawelev": q = self.setbool(o, v)
        elif o == "drawlakes": q = self.setbool(o, v)
        elif o == "drawlsmask": q = self.setbool(o, v)
        elif o == "drawmeridians": q = self.setbool(o, v)
        elif o == "drawminormeridians": q = self.setbool(o, v)
        elif o == "drawminorparallels": q = self.setbool(o, v)
        elif o == "elevcolor": q = self.setcolor(o, v)
        elif o == "elevlw": q = self.setfloat(o, v, 0)
        elif o == "fontsize": q = self.setfloat(o, v, 0)
        elif o == "landcolor": q = self.setcolor(o, v)
        elif o == "linewidth": q = self.setfloat(o, v, 0)
        elif o == "majormeridianscolor": q = self.setcolor(o, v)
        elif o == "majormeridianslw": q = self.setfloat(o, v, 0)
        elif o == "majorparallelscolor": q = self.setcolor(o, v)
        elif o == "majorparallelslw": q = self.setfloat(o, v, 0)
        elif o == "mapres": q = self.setenum(o, v, ("c","l","i","h","f"))
        elif o == "meridiansbase": q = self.setfloat(o, v, 0)
        elif o == "minormeridianscolor": q = self.setcolor(o, v)
        elif o == "minormeridianslw": q = self.setfloat(o, v, 0)
        elif o == "nminormeridians": q = self.setint(o, v, 0)
        elif o == "nminorparallels": q = self.setint(o, v, 0)
        elif o == "padding": q = self.setfloat(o, v, 0)
        elif o == "parallelsbase": q = self.setfloat(o, v, 0)
        elif o == "plotheight": q = self.setfloat(o, v, 0)
        elif o == "title": q = self.setstr(o, v)
        elif o == "trajcolors": q = self.settuple(o, v, self.setcolor)
        elif o == "trajlws": q = self.settuple(o, v, self.setfloat, 0)
        elif o == "trajticks": q = self.setint(o, v, -1)
        elif o == "trajnminorticks": q = self.setint(o, v, -1)
        elif o == "watercolor": q = self.setcolor(o, v)
        else: raise ValueError("Unrecognized option: %s" % o)
        setattr(self, o, q)


class ProjOpts(AutoOpts):
    boundinglat = None
    lat_0 = None
    lat_1 = None
    lat_2 = None
    lat_ts = None
    lon_0 = None
    lon_1 = None
    lon_2 = None
    
    def setopt(self, o, v):
        if   o == "boundinglat": q = self.setlat(o, v)
        elif o == "lon_0": q = self.setlon(o, v)
        elif o == "lon_1": q = self.setlon(o, v)
        elif o == "lon_2": q = self.setlon(o, v)        
        elif o == "lat_0": q = self.setlat(o, v)
        elif o == "lat_1": q = self.setlat(o, v)
        elif o == "lat_2": q = self.setlat(o, v)
        elif o == "lat_ts": q = self.setlat(o, v)
        
        else: raise ValueError
        setattr(self, o, q)


class TimeLocator(mpl.ticker.Locator):
    def __init__(self, n, time, time2dt, \
                 steps=     [1,     2, 5, 10, 15, 30, 60, 300, 600, 900],
                 minorsteps=[0.2, 0.5, 1,  2,  3,  5, 10,  60, 120, 300]):
        self.n = int(n)
        self.time = time
        self.time2dt = time2dt
        self.steps = np.array(steps, np.float)
        self.minorsteps = np.array(minorsteps, np.float)
        self.minorlocs = []

    def __call__(self):
        vmin, vmax = self.axis.get_view_interval()
        vmin, vmax = int(vmin), int(vmax)
        if len(self.time) == 0 or self.n <= 0: return []
        if vmin < 0: vmin = 0
        if vmax >= len(self.time): vmax = len(self.time) - 1
        if vmax < vmin: vmax = vmin = 0
        td = self.time2dt(self.time[vmax]) - self.time2dt(self.time[vmin])
        # Time difference in seconds.
        nseconds = td.days*86400 + td.seconds + td.microseconds*0.000001
        if nseconds == 0: return []
        ratio = 1.0 * (vmax-vmin)/nseconds
        time0 = self.time2dt(self.time[vmin])
        # Adjust to the nearest minute. We introduce a correction of 200ms
        # (1 ray is about 49ms), so that we don't get min:59.
        offset = -ratio * (time0.microsecond * 0.000001 + \
                           time0.second + \
                           time0.minute * 60 - 0.2)
        stepdiffs = self.steps - nseconds/self.n
        np.place(stepdiffs, stepdiffs < 0, float("infinity"))
        i = stepdiffs.argmin()
        base = ratio * self.steps[i]
        minorbase = ratio * self.minorsteps[i]
        offset = offset % base
        self.minorlocs = np.arange(vmin + offset - base, vmax + offset + base,
                                   minorbase)
        return np.arange(vmin + offset, vmax + offset, base)


class TimeMinorLocator(mpl.ticker.Locator):
    def __call__(self):
        locator = self.axis.get_major_locator()
        if isinstance(locator, TimeLocator):
            return locator.minorlocs
        else:
            return []

        
class TimeFormatter(mpl.ticker.Formatter):
    def __init__(self, time, time2dt):
        self.time = time
        self.time2dt = time2dt

    def __call__(self, x, pos=None):
        i = int(x)
        if i >= len(self.time) or i < 0: return "undef"
        return self.time2dt(self.time[i]).strftime("%H:%M:%S")


class CopyLocator(mpl.ticker.Locator):
    def __init__(self, axis):
        self.model_axis = axis
    
    def __call__(self):
        return self.model_axis.get_majorticklocs()


class SciFormatter(mpl.ticker.Formatter):
    def __call__(self, x, pos=None):
        if x == 0.0: return "0.0"
        y = log(abs(x), 10)
        n = int(floor(y))
        if n < -1 or n > 2: return "%.1fx10$^{%d}$" % (x/10**n, n)
        else: return "%.1f" % (x,)

class HorizontalExtent(object):
    TYPE_NONE = 0
    TYPE_ALONG_TRACK = 1
    TYPE_ALONG_TRACK_ACROSS_TRACK = 2
    TYPE_ABSOLUTE_TIME = 3
    TYPE_RELATIVE_TIME = 4
    TYPE_LON_LAT = 5
    
    extent_type = TYPE_NONE
    
    along_track = [0, -1]
    across_track = [0, -1]
    absolute_time = [None, None] # [dt.time(), dt.time()]
    relative_time = [None, None] # [dt.timedelta(), dt.timedelta()]
    lon = [-180, 180]
    lat = [-90, 90]


class Options(object):
    """This class holds command-line options."""
    hextent = HorizontalExtent()
    fnames = []
    vextent = np.array((float("-infinity"), float("infinity")), dtype=np.float)
    resolution = None
    aspect = 14.0
    dpi = 300
    outfname = "ccplot.png"
    plot_type = None
    print_info_only = False
    cmapfname = None
    modis_band = 1
    modis_band_mode = BAND_MODE_RADIANCE
    projection = "cyl"
    radius = None
    proj_opts = ProjOpts()
    plot_opts = PlotOpts()


#
# Functions.
#

def report_memory():
    pid = os.getpid()
    a2 = os.popen("ps -p %d -o rss,vsz,%%mem" % pid).readlines()
    print "MEMORY:", a2[1],
    return int(a2[1].split()[1])


def warn(s):
    global program_name
    print >> sys.stderr, "%s: Warning: %s" % (program_name, s)    


def info(s):
    global verbose
    if verbose: print s


def norm_index(x, a, b):
    if x > b: return b
    if x < a: x += b
    if x < a: return a
    return x

def modis_band_wavelength(band):
    global MODIS_WAVELENGTHS
    return MODIS_WAVELENGTHS[int(band)-1]

def radiance2temp(L, lamb):
    """Converts radiace to temperature by inverse Planck's law.
    
    Arguments:
        L       -- radiance in W m^-2 m^-1
        lamb    -- wavelength in m

    Returns:
        Temerature in K.
    """
    global PLANCK_C1, PLANCK_C2
    return PLANCK_C2 / (lamb * np.log(PLANCK_C1 / (lamb**5 * L * 1E6) + 1))


def version():
    """Prints version information and exits with 0."""
    global __version__
    print >> sys.stderr, "ccplot %s" % __version__
    print >> sys.stderr, ""
    print >> sys.stderr, "Third-party libraries:"
    print >> sys.stderr, "matplotlib %s" % mpl.__version__
    print >> sys.stderr, "basemap %s" % basemap.__version__
    print >> sys.stderr, ""
    print >> sys.stderr, "Copyright 2009, 2010 Peter Kuma."
    print >> sys.stderr, "This software is provided under the terms of a 2-clause BSD licence."
    sys.exit(0)
    

def usage():
    """Prints usage information and exits the program with return value of 1."""
    global program_name
    print >> sys.stderr, "Usage: %s [OPTION]... TYPE FILE..." % program_name
    print >> sys.stderr, "       %s -i FILE" % program_name
    print >> sys.stderr, "       %s -V" % program_name
    print >> sys.stderr, "Try `%s -h' for more information." % program_name
    sys.exit(1)


def help_and_exit():
    """Prints help and exits the program with return value of 0."""
    global program_name

    print >> sys.stderr, "\
%s: [OPTION]... TYPE FILE...\n\
%s: -i FILE\n\
%s: -V\n\
\n\
Plot data from CloudSat, CALIPSO and Aqua MODIS product files.\n\
Example: %s -c calipso.cmap -x 11000..13000 -y 0..25000 -o out.png calipso532 \
CAL_LID_L1-Prov-V2-01.2006-08-12T19-15-34ZD.hdf\n\
\n\
Where OPTION is one of:\n\
  -a RATIO                      aspect ratio of profile and layer plots in\n\
                                km horizontal per km vertical\n\
  -c FILE                       colormap file\n\
  -d DPI                        DPI of the output file\n\
  -h                            print help information and exit\n\
  -i FILE                       print information about FILE\n\
  -m BAND                       MODIS band (e.g. r1 for reflectance band 1,\n\
                                x31 for radiance band 31)\n\
  -o OUTFILE                    output file, type is determined by extension\n\
  -p PROJECTION[:PROJOPTS]      projection type and options\n\
  -r RADIUS                     interpolation radius\n\
  -v                            verbose mode\n\
  -V                            print version information and exit\n\
  -x FROM..TO[,FROM..TO]        horizontal extent\n\
  -y FROM..TO                   vertical extent in meters\n\
  -z OPTION=VAL[,OPTION=VAL]    list of option-value pairs\n\
\n\
OPTION is one of:\n\
  Use -z help for a list of available options. \n\
\n\
PROJECTION is one of:\n\
  Use -p help for a list of available projections.\n\
\n\
PROJOPTS is a list of option value pairs, where option is one of:\n\
  boudinglat\n\
  lat_0\n\
  lat_1\n\
  lat_2\n\
  lat_ts\n\
  lon_0\n\
  lon_1\n\
  lon_2\n\
\n\
TYPE is one of:\n\
  cloudsat-reflec\n\
  calipso532\n\
  calipso532p\n\
  calipso1064\n\
  calipso-cratio\n\
  calipso-dratio\n\
  calipso532-layer\n\
  calipso1064-layer\n\
  calipso-cratio-layer\n\
  calipso-dratio-layer\n\
  calipso-temperature-layer\n\
  orbit\n\
  orbit-clipped\n\
\n\
FILE is a CloudSat or Aqua MODIS HDF-EOS2 file, or a CALIPSO HDF4 file.\n\
\n\
Report bugs to <ccplot-general@lists.sourceforge.net>." % \
    (program_name, program_name, program_name, program_name)
    
    sys.exit(0)


def help_options():
    print "\
cbspacing\n\
coastlinescolor\n\
coastlineslw\n\
countriescolor\n\
countrieslw\n\
drawcoastlines\n\
drawcountries\n\
drawlakes\n\
drawlsmask\n\
drawmeridians\n\
drawminormeridians\n\
drawminorparallels\n\
drawparallels\n\
fontsize\n\
landcolor\n\
majormeridianscolor\n\
majormeridianslw\n\
majorparallelscolor\n\
majorparallelslw\n\
mapres\n\
meridiansbase\n\
minormeridianscolor\n\
minormeridianslw\n\
minorparallelscolor\n\
minorparallelslw\n\
nminormeridians\n\
nminorparallels\n\
padding\n\
parallelsbase\n\
plotheight\n\
trajcolors\n\
title\n\
trajlws\n\
trajnminorticks\n\
trajticks\n\
watercolor"
    sys.exit(0)


def help_projections():
    print "\
aeqd 		Azimuthal Equidistant\n\
poly 		Polyconic\n\
gnom 		Gnomonic\n\
moll 		Mollweide\n\
tmerc 		Transverse Mercator\n\
nplaea 		North-Polar Lambert Azimuthal\n\
gall 		Gall Stereographic Cylindrical\n\
mill 		Miller Cylindrical\n\
merc 		Mercator\n\
stere 		Stereographic\n\
npstere 	North-Polar Stereographic\n\
vandg 		van der Grinten\n\
laea 		Lambert Azimuthal Equal Area\n\
mbtfpq 		McBryde-Thomas Flat-Polar Quartic\n\
sinu 		Sinusoidal\n\
spstere 	South-Polar Stereographic\n\
lcc 		Lambert Conformal\n\
npaeqd 		North-Polar Azimuthal Equidistant\n\
eqdc 		Equidistant Conic\n\
cyl 		Cylindrical Equidistant\n\
aea 		Albers Equal Area\n\
spaeqd 		South-Polar Azimuthal Equidistant\n\
ortho 		Orthographic\n\
cass 		Cassini-Soldner\n\
splaea 		South-Polar Lambert Azimuthal\n\
robin 		Robinson"
    sys.exit(0)


def parse_extent(text):
    """"Parses extent in format from..to or from..to,from..to and returns
    an instance of class HorizontalExtent. Raises ValueError on parsing
    error.

    Arguments:
        text -- text to be parsed

    Returns:
        Instance of HorizontalExtent.
    """
    e = HorizontalExtent()
    
    # Match longitude/latitude in the form
    # lon{E|W}..lon{E|W},lat{S|N}..lat{S|N}
    r1 = re.compile(r"^(\d+(?:\.\d+)?)(E|W)\.\.(\d+(?:\.\d+)?)(E|W),(\d+(?:\.\d+)?)(S|N)\.\.(\d+(?:\.\d+)?)(S|N)$")
    m1 = r1.match(text)
    
    # Match longitude/latitude in the form
    # lat{S|N}..lat{S|N},lon{E|W}..lon{E|W}
    r1_rev = re.compile(r"^(\d+(?:\.\d+)?)(S|N)\.\.(\d+(?:\.\d+)?)(S|N),(\d+(?:\.\d+)?)(E|W)\.\.(\d+(?:\.\d+)?)(E|W)$")
    m1_rev = r1_rev.match(text)
    
    # Match absolute time in format hour:min[:sec]..hour:min[:sec].
    r2 = re.compile(r"^(\d?\d):(\d\d)(?::(\d\d))?\.\.(\d?\d):(\d\d)(?::(\d\d))?$")
    m2 = r2.match(text)
    
    # Match relative time in format +/-[hour:]min:sec..+/-[hour:]min:sec.
    r3 = re.compile(r"^(\+|-)(?:(\d+):)?(\d?\d):(\d\d)\.\.(\+|-)(?:(\d+):)?(\d?\d):(\d\d)$")
    m3 = r3.match(text)
    
    # Match along_track,across_track, i.e NUM..NUM,NUM..NUM.
    r4 = re.compile(r"^((?:\+|-)?\d+)\.\.((?:\+|-)?\d+),((?:\+|-)?\d+)\.\.((?:\+|-)?\d+)$")
    m4 = r4.match(text)
    
    # Match along_track, i.e NUM..NUM.
    r5 = re.compile(r"^((?:\+|-)?\d+)\.\.((?:\+|-)?\d+)$")
    m5 = r5.match(text)
    
    if m1 != None: # Match longitude,latitude.
        gs = m1.groups()
        e.extent_type = HorizontalExtent.TYPE_LON_LAT
        e.lon = [float(gs[0])*(int(gs[1]=="E")*2-1),
                 float(gs[2])*(int(gs[3]=="E")*2-1)]
        e.lat = [float(gs[4])*(int(gs[5]=="N")*2-1),
                 float(gs[6])*(int(gs[7]=="N")*2-1)]

    elif m1_rev != None: # Match latitude,longitude.
        gs = m1_rev.groups()
        e.extent_type = HorizontalExtent.TYPE_LON_LAT
        e.lat = [float(gs[0])*(int(gs[1]=="N")*2-1),
                 float(gs[2])*(int(gs[3]=="N")*2-1)]
        e.lon = [float(gs[4])*(int(gs[5]=="E")*2-1),
                 float(gs[6])*(int(gs[7]=="E")*2-1)]

    elif m2 != None: # Match absolute time.
        gs = m2.groups()
        e.extent_type = HorizontalExtent.TYPE_ABSOLUTE_TIME
        for k in (0, 3):
            hours = int(gs[k]) if gs[k] != None else 0
            minutes = int(gs[k+1]) if gs[k+1] != None else 0
            seconds = int(gs[k+2]) if gs[k+2] != None else 0
            if hours > 23 or minutes > 59 or seconds > 59:
                raise ValueError
            e.absolute_time[k/3] = dt.time(hours, minutes, seconds)

    elif m3 != None: # Match relative time.
        gs = m3.groups()
        e.extent_type = HorizontalExtent.TYPE_RELATIVE_TIME
        for k in (0, 4):
            sign = -1 if gs[k] == "-" else 1
            hours = int(gs[k+1]) if gs[k+1] != None else 0
            minutes = int(gs[k+2]) if gs[k+2] != None else 0
            seconds = int(gs[k+3]) if gs[k+3] != None else 0
            if minutes > 59 or seconds > 59: raise ValueError
            e.relative_time[k/4] = sign*dt.timedelta(0, seconds,
                                                     0, 0, minutes, hours)        
    
    elif m4 != None: # Match along_track,across_track.
        gs = m4.groups()
        e.extent_type = HorizontalExtent.TYPE_ALONG_TRACK_ACROSS_TRACK
        e.along_track = [int(gs[0]), int(gs[1])]
        e.across_track = [int(gs[2]), int(gs[3])]
        
    elif m5 != None: # Match along_track.
        gs = m5.groups()
        e.extent_type = HorizontalExtent.TYPE_ALONG_TRACK
        e.along_track = [int(gs[0]), int(gs[1])]
    
    else:
        raise ValueError
    
    if e.lon[0] < -180.0: e.lon[0] = -180.0
    if e.lon[0] > 180.0: e.lon[0] = 180.0

    if e.lon[1] < -180.0: e.lon[1] = -180.0
    if e.lon[1] > 180.0: e.lon[1] = 180.0
    
    if e.lat[0] < -90.0: e.lat[0] = -90.0
    if e.lat[0] > 90.0: e.lat[0] = 90.0

    if e.lat[1] < -90.0: e.lat[1] = -90.0
    if e.lat[1] > 90.0: e.lat[1] = 90.0
    
    if e.lon[0] >= e.lon[1]: e.lon.reverse()
    if e.lat[0] >= e.lat[1]: e.lat.reverse()

    return e


def parse_options(argv):
    """Parses command-line arguments.
    
    Arguments:
        argv -- array of command-line arguments
    
    Returns:
        instance of Options
    """
    opts = Options()

    if len(argv) < 2: usage()
    if argv[1] == "-h" and len(argv) == 2: help_and_exit()
    if argv[1] == "-V" and len(argv) == 2: version()
    
    if argv[1] == "-i" and len(argv) > 2:
        opts.fnames = argv[2:]
        opts.print_info_only = True
        return opts
    
    try: cmdopts, args = getopt.getopt(argv[1:], "a:c:d:m:o:p:r:vx:y:z:")
    except getopt.error: usage()
  
    for o, a in cmdopts:
        try:
            if o == "-a":
                opts.aspect = float(a)
                if opts.aspect <= 0.0: raise ValueError
            elif o == "-c": opts.cmapfname = a
            elif o == "-d":
                opts.dpi = int(a)
                if opts.dpi <= 0: raise ValueError
            elif o == "-m":
                if a[0] == "r": opts.modis_band_mode = BAND_MODE_REFLECTANCE
                elif a[0] == "x": opts.modis_band_mode = BAND_MODE_RADIANCE
                else: raise ValueError
                if a[-2:] == "hi":
                    opts.modis_band = int(a[1:-2]) + 0.5
                elif a[-2:] == "lo":
                    opts.modis_band = int(a[1:-2])
                else:
                    opts.modis_band = int(a[1:])
            elif o == "-o": opts.outfname = a
            elif o == "-p":
                if a == "help": help_projections()
                
                opts.projection,s,opts_str  = a.partition(":")

                parts = opts_str.split(",")
                for p in parts:
                    if p == "": continue
                    opt,s,val = p.partition("=")
                    opts.proj_opts.setopt(opt, val)

                if opts.projection not in SUPPORTED_PROJECTIONS:
                    raise ValueError
            elif o == "-r":
                opts.radius = int(a)
                if opts.radius < 0: raise ValueError
            elif o == "-v":
                global verbose
                verbose = True
            elif o == "-y":
                parts = a.partition("..")
                if parts[0] != "": opts.vextent[0] = int(parts[0])
                if parts[2] != "": opts.vextent[1] = int(parts[2])
            elif o == "-x":
                opts.hextent = parse_extent(a)
            elif o == "-z":
                if a == "help": help_options()
                parts = a.split(",")
                for p in parts:
                    opt,s,val = p.partition("=")
                    opts.plot_opts.setopt(opt, val)
        except ValueError, err:
            if err != None:
                fail("Invalid argument passed to %s: %s" % (o, err))
            else:
                fail("Invalid argument passed to %s" % o)
        except KeyError:
            fail("Invalid argument passed to %s" % o)

    if len(args) < 2: usage()
    opts.plot_type = args[0]
    opts.fnames = args[1:]

    return opts
    

def loadcolormap(filename, name):
    """"Returns a tuple of matplotlib colormap, matplotlib norm,
    and a list of ticks loaded from the file filename in format:
    
    BOUNDS
    from1 to1 step1
    from2 to2 step2
    ...
    
    TICKS
    from1 to1 step1
    from2 to2 step2
    
    COLORS
    r1 g1 b1
    r2 g2 b2
    ...
    
    UNDER_OVER_BAD_COLORS
    ro go bo
    ru gu bu
    rb gb bb
    
    Where fromn, ton, stepn are floating point numbers as would be supplied
    to numpy.arange, and rn, gn, bn are the color components the n-th color
    stripe. Components are expected to be in base10 format (0-255).
    UNDER_OVER_BAD_COLORS section specifies colors to be used for
    over, under and bad (masked) values in that order.

    Arguments:
        filename    -- name of the colormap file
        name        -- name for the matplotlib colormap object

    Returns:
        A tuple of: instance of ListedColormap, instance of BoundaryNorm, ticks.
    """
    global CCPLOT_CMAP_PATH
    
    bounds = []
    ticks = []
    rgbarray = []
    specials = []
    mode = "COLORS"
    
    fp = None
    if filename.startswith("/") or \
       filename.startswith("./") or \
       filename.startswith("../"):
        try:
            fp = open(filename, "r")
        except IOError, err: fail(err)
    else:
        for path in CCPLOT_CMAP_PATH.split(":"):
            try:
                fp = open(os.path.join(path, filename), "r")
            except IOError, err: continue
            break
    if fp == None: fail("%s: File not found" % filename)

    try:
        lines = fp.readlines()
        for n, s in enumerate(lines):
            s = s.strip()
            if len(s) == 0: continue
            if s in ("BOUNDS", "TICKS", "COLORS", "UNDER_OVER_BAD_COLORS"):
                mode = s
                continue

            a = s.split()
            if len(a) not in (3, 4):
                raise ValueError("Invalid number of fields")

            if mode == "BOUNDS":
                bounds += list(np.arange(float(a[0]), float(a[1]), float(a[2])))
            elif mode == "TICKS":
                ticks += list(np.arange(float(a[0]), float(a[1]), float(a[2])))
            elif mode == "COLORS":
                rgba = [int(c)/256.0 for c in a]
                if len(rgba) == 3: rgba.append(1)
                rgbarray.append(rgba)
            elif mode == "UNDER_OVER_BAD_COLORS":
                rgba = [int(c)/256.0 for c in a]
                if len(rgba) == 3: rgba.append(1)
                specials.append(rgba)

    except IOError, err:
        fail(err)
    except ValueError, err:
        fail("Error reading `%s' on line %d: %s" % (filename, n+1, err))
   
    if (len(rgbarray) > 0):
        colormap = mpl.colors.ListedColormap(rgbarray, name)
        try:
            colormap.set_under(specials[0][:3], specials[0][3])
            colormap.set_over(specials[1][:3], specials[1][3])
            colormap.set_bad(specials[2][:3], specials[2][3])
        except IndexError: pass
    else:
        colormap = None
        
    if len(bounds) == 0:
        norm = None
    else:
        norm = mpl.colors.BoundaryNorm(bounds, colormap.N)
    if len(ticks) == 0: ticks = None
    return (colormap, norm, ticks)


def print_info(niofile):
    """Prints information about the file.
       
    Arguments:
        niofile -- NIO module file from which the information is to be read
    """
    ftype = None
    try: # Try CALIPSO names.
        time = niofile.variables["Profile_UTC_Time"][:,0]
        start_time = None
        time2dt = calipso_time2dt
        height = CALIPSO_HEIGHT
        backscat532 = niofile.variables["Total_Attenuated_Backscatter_532"]
        lat  = niofile.variables["Latitude"][:,0]
        lon  = niofile.variables["Longitude"][:,0]
        nbin = backscat532.shape[1]
        nray = len(time)
        ftype = "CALIPSO"
    except (KeyError, IndexError): pass
    try: # Try CloudSat names.
        time = niofile.variables["Profile_time_2B_GEOPROF"]
        lat = niofile.variables["Latitude_2B_GEOPROF"][:]
        lon = niofile.variables["Longitude_2B_GEOPROF"][:]
        height = niofile.variables["Height_2B_GEOPROF"][0][::-1]
        time2dt = cloudsat_time2dt
        st = niofile.attributes["start_time_2B_GEOPROF"]
        start_time = dt.datetime.strptime(st, "%Y%m%d%H%M%S")
        del st
        nbin = niofile.dimensions["nbin_2B_GEOPROF"]
        nray = len(time)
        ftype = "CloudSat"
    except (KeyError, IndexError): pass
    try: # Try MODIS names.
        lon = niofile.variables["Longitude_MODIS_SWATH_Type_L1B"][:,0]
        lat = niofile.variables["Latitude_MODIS_SWATH_Type_L1B"][:,0]
        ftype = "MODIS"
    except (KeyError, IndexError): pass

    if ftype == None: fail("Unsupported file format")

    if ftype == "MODIS":
        print "Type: %s" % ftype
        print "Longitude: %s %s" % (lon2str(np.min(lon)), lon2str(np.max(lon)))
        print "Latitude: %s %s" % (lat2str(np.min(lat)), lat2str(np.max(lat)))
    else:
        time1 = time2dt(time[0], start_time).strftime("%Y-%m-%d %H:%M:%S")
        time2 = time2dt(time[-1], start_time).strftime("%Y-%m-%d %H:%M:%S")
        print "Type: %s" % ftype
        print "Time: %s, %s" % (time1, time2)
        print "Height: %dm, %dm" % (height[0], height[-1])
        print "nray: %d" % nray
        print "nbin: %d" % nbin
        print "Longitude: %s, %s" % (lon2str(np.min(lon)), lon2str(np.max(lon)))
        print "Latitude: %s, %s" % (lat2str(np.min(lat)), lat2str(np.max(lat)))


def calipso_time2dt(time, start_time=None):
    """Converts a float in format yymmdd.ffffffff to a instance of python
    datetime class.
    
    Arguments:
        time        -- float in format yymmdd.ffffffff
        start_time  -- ignored 
    
    Returns:
        An instance of datetime.
    """
    d = int(time % 100)
    m = int((time-d) % 10000)
    y = int(time-m-d)
    return dt.datetime(2000 + y//10000, m//100, d) + dt.timedelta(time % 1)


def cloudsat_time2dt(time, start_time):
    """Converts time in seconds to a instance of python datetime class.
    
    Arguments:
        time        -- seconds from start_time
        start_time  -- python datetime
    
    Returns:
        An instance of datetime.
    """
    return start_time + dt.timedelta(0, float(time))
    
    
def fit_colorbar(fig, axes, aspect=0.03, space=0.4, padding=0.0):
    """Creates new axes for a colorbar at the expense of main axes.
    
    Arguments:
        fig     -- an instance of mpl.Figure
        axes    -- an instance of mpl.Axes
        aspect  -- colorbar axes aspect ratio

    Returns:
        An instance of mpl.Axes.
    """
    x, y, width, height = get_axes_bounds(fig, axes)
    return new_axes(fig, x + width + space, y, aspect*height, height,
                    padding=padding)
    

def stripstr(s1, s2):
    i = s1.rfind(s2)
    if i == -1: return s1
    else: return s1[:i]


def lon2str(lonf, degree=""):
    if lonf >= 0.0: return "%.2f%sE" % (lonf, degree)
    else: return "%.2f%sW" % (-lonf, degree)


def lat2str(latf, degree=""):
    if latf >= 0.0: return "%.2f%sN" % (latf, degree)
    else: return "%.2f%sS" % (-latf, degree)


def setup_lonlat_axes(fig, axes, lon, lat):
    @mpl.ticker.FuncFormatter
    def lonlat_formatter(x, pos=None):
        i = long(x)
        if x < 0 or x >= len(lon): return ""
        return "%s\n%s" % (lon2str(lon[i], "$\degree$"), \
                           lat2str(lat[i], "$\degree$"))

    llaxes = fig.add_axes(axes.get_position())
    llaxes.yaxis.set_visible(False)
    llaxes.axesPatch.set_alpha(0.0)
    llaxes.set_xlim(axes.get_xlim())
    llaxes.set_ylim(axes.get_ylim())
    llaxes.set_aspect(axes.get_aspect())
    llaxes.xaxis.set_major_locator(CopyLocator(axes.xaxis))

    for tick in llaxes.xaxis.get_major_ticks():
        tick.tick1On = tick.label1On = False
        tick.tick2On = tick.label2On = True

    for line in llaxes.xaxis.get_ticklines():
        line.set_marker(mpl.lines.TICKUP)

    for label in llaxes.xaxis.get_ticklabels():
        label.set_y(label.get_position()[1] + 0.01)

    llaxes.xaxis.set_major_formatter(lonlat_formatter)


def get_axes_bounds(fig, axes):
    figw, figh = fig.get_size_inches()
    xrel, yrel, wrel, hrel = axes.get_position(True).bounds
    return figw*xrel, figh*(1-yrel-hrel), figw*wrel, figh*hrel


def resize_figure(fig, figw, figh):
    figw_old, figh_old = fig.get_size_inches()

    fig.set_size_inches(figw, figh)

    xratio = figw_old/figw
    yratio = figh_old/figh

    for ax in fig.axes:
        xrel, yrel, wrel, hrel = ax.get_position(True).bounds
        yrel = 1-yrel
        ax.set_position([xrel*xratio, 1-yrel*yratio, wrel*xratio, hrel*yratio])


def expand_axes(fig, axes, width, height, padding):
    figw_old, figh_old = fig.get_size_inches()
    x, y, w, h = get_axes_bounds(fig, axes)
    
    figw = max(figw_old, x + width + padding)
    figh = max(figh_old, y + height + padding)
    
    resize_figure(fig, figw, figh)
    x, y, w, h = get_axes_bounds(fig, axes)
    axes.set_position([x/figw, 1-(y+height)/figh, width/figw, height/figh])
        

def new_axes(fig, x, y, width, height, padding=1.0):
    figw_old, figh_old = fig.get_size_inches()
    
    figw = max(figw_old, x + width + padding)
    figh = max(figh_old, y + height + padding)

    resize_figure(fig, figw, figh)
    return fig.add_axes([x/figw, 1-(y+height)/figh, width/figw, height/figh])


def time2ray(t, time, time2dt):
    """Returns index i of 1-dimensional array time whose value of
    time2dt(time[i]) best matches dt.time instance t. Returns -1 if time
    is empty.
    """
    
    a = 0
    b = len(time)-1
    i = 0
    
    if len(time) == 0: return -1

    if isinstance(t, dt.timedelta):
        if t < dt.timedelta(0): ref_dt = time2dt(time[-1]) + t
        else: ref_dt = time2dt(time[0]) + t
    else: # dt.time expected.    
        date0 = time2dt(time[0]).date()
        time0 = time2dt(time[0]).time()
        if t < time0: ref_dt = dt.datetime.combine(date0 + dt.timedelta(1), t)
        else: ref_dt = dt.datetime.combine(date0, t)
    
    # Simple binary search.
    # TODO: Search by taking differentials would be much faster.
    while a < b: 
        i = (a + b)/2
        dti = time2dt(time[i])
        if ref_dt < dti:
            b = i
        else:
            a = i+1
    try:
        if abs(ref_dt - time2dt(time[i-1])) < abs(ref_dt-dti): return i - 1
        if abs(ref_dt - time2dt(time[i+1])) < abs(ref_dt-dti): return i + 1
    except KeyError: pass
    return i


def lonlat2ray(lonextent, latextent, lon, lat):
    mask = (lon > lonextent[0]) & (lon < lonextent[1]) & \
           (lat > latextent[0]) & (lat < latextent[1])
    
    e1 = e2 = 0
    
    i = 0
    n = len(mask)
    while i < n and not mask[i]:
        e1 = i
        i = i + 1
    while i < n and mask[i]:
        e2 = i
        i = i + 1

    return e1, e2


def figure_title(fig, opts, title):
    if opts.title != None:
        title = opts.title
    figw, figh = fig.get_size_inches()
    fig.text(opts.padding/figw, 1-opts.padding/figh/3.0, title, weight="bold")


def plot_profile(what, fname, niofile, fig, axes, hextent=HorizontalExtent(),
              vextent=np.array((float("-infinity"), float("infinity"))),
              aspect=1410.0, colormap=None, norm=None, ticks=None, radius=None,
              opts=PlotOpts()):
    """Plot profile or layer as specified by argument what.

    Arguments:
        what            -- plot type string
        fname           -- file name
        niofile         -- NIO module file to read data from
        fig             -- matplotlib Figure instance to draw onto
        axes            -- matplotlib Axes instance to draw onto
        hextent         -- an instance of HorizontalExtent
        vextent         -- vertical extent, a pair of low and high boundary
                           in meters
        aspect          -- aspect ratio in s per km
        colormap        -- matplotlib Colormap instance
        norm            -- matplotlib Normalize instance
        ticks           -- a list of ticks to be drawn on colorbar
    """
    global CALIPSO_HEIGHT, ATRAIN_SPEED, PROFILE_BINHEIGHT

    #
    # Variable initialization.
    #
    time = None
    lat = None
    lon = None
    reflec = None
    height = None
    start_time = None
    nbin = 0
    nray = 0
    backscat532 = None
    backscat532p = None
    backscat1064 = None
    topalt = None
    basealt = None
    backscat532_layer = None
    backscat1064_layer = None
    cratio_layer = None
    dratio_layer = None
    temperature_layer = None
    nlayer = 0
    elevation = None

    #
    # Data retrieval.
    #
    try: # Try CloudSat names.
        time = niofile.variables["Profile_time_2B_GEOPROF"]
        lat = niofile.variables["Latitude_2B_GEOPROF"]
        lon = niofile.variables["Longitude_2B_GEOPROF"]
        reflec = niofile.variables["Radar_Reflectivity_2B_GEOPROF"]
        height = niofile.variables["Height_2B_GEOPROF"]
        start_time = niofile.attributes["start_time_2B_GEOPROF"]
        nbin = niofile.dimensions["nbin_2B_GEOPROF"]
        nray = len(time)
    except KeyError: pass
    try: # Try common CALIPSO profile/layer names.
        time = niofile.variables["Profile_UTC_Time"]
        lat  = niofile.variables["Latitude"]
        lon  = niofile.variables["Longitude"]
        nray = len(time)
    except KeyError: pass
    try: # Try CALIPSO profile names.
        backscat532 = niofile.variables["Total_Attenuated_Backscatter_532"]
        backscat532p = niofile.variables["Perpendicular_Attenuated_Backscatter_532"]
        backscat1064 = niofile.variables["Attenuated_Backscatter_1064"]
        elevation = niofile.variables["Surface_Elevation"]
        # CALIPSO doesn't call them rays (horizontal) and bins
        # (vertical); anyway, it should be clear enough.
        nbin = backscat532.shape[1]
    except KeyError: pass
    try: # Try CALIPSO layer names.
        topalt  = niofile.variables["Layer_Top_Altitude"]
        basealt = niofile.variables["Layer_Base_Altitude"]
        backscat532_layer = niofile.variables["Integrated_Attenuated_Backscatter_532"]
        backscat1064_layer = niofile.variables["Integrated_Attenuated_Backscatter_1064"]
        cratio_layer = niofile.variables["Integrated_Attenuated_Total_Color_Ratio"]
        dratio_layer = niofile.variables["Integrated_Volume_Depolarization_Ratio"]
        temperature_layer = niofile.variables["Midlayer_Temperature"]
        nlayer = niofile.variables["Number_Layers_Found"]
        nbin = len(CALIPSO_HEIGHT)
    except KeyError: pass

    try:
        # Determine what time conversion function to apply. We need this now
        # in order to convert time extent (if set) to extent in rays.
        if what.startswith("cloudsat"):
            start_time_dt = dt.datetime.strptime(start_time, "%Y%m%d%H%M%S")
            time2dt = lambda t: cloudsat_time2dt(t, start_time_dt)
        else: time2dt = calipso_time2dt

        if hextent.extent_type == HorizontalExtent.TYPE_ABSOLUTE_TIME:
            time_temp = time[:,0] if time.rank == 2 else time
            e1 = time2ray(hextent.absolute_time[0], time_temp, time2dt)
            e2 = time2ray(hextent.absolute_time[1], time_temp, time2dt)
            del time_temp
        elif hextent.extent_type == HorizontalExtent.TYPE_RELATIVE_TIME:
            time_temp = time[:,0] if time.rank == 2 else time
            e1 = time2ray(hextent.relative_time[0], time_temp, time2dt)
            e2 = time2ray(hextent.relative_time[1], time_temp, time2dt)
            del time_temp
        elif hextent.extent_type == HorizontalExtent.TYPE_LON_LAT:
            lon_temp = lon[:,0] if lon.rank == 2 else lon[:]
            lat_temp = lat[:,0] if lat.rank == 2 else lat[:]
            e1, e2 = lonlat2ray(hextent.lon, hextent.lat, lon_temp, lat_temp)
            del lon_temp, lat_temp
        elif hextent.extent_type == HorizontalExtent.TYPE_ALONG_TRACK:
            e1, e2 = hextent.along_track
        elif hextent.extent_type == HorizontalExtent.TYPE_NONE:
            e1 = 0
            e2 = -1
        else: fail("Extent type not supported by profile plots")

        e1 = norm_index(e1, 0, nray)
        e2 = norm_index(e2, 0, nray)
        if e1 >= e2: fail("Invalid extent")        
        
        if what.startswith("cloudsat"):
            product_name = "CloudSat Profile"
            lon = lon[e1:e2]
            lat = lat[e1:e2]
            height = height[e1:e2][:,::-1]
            time = time[e1:e2]
        elif what.startswith("calipso"):
            product_name = "CALIPSO Profile"
            lon = lon[e1:e2,0]
            lat = lat[e1:e2,0]
            # WORKAROUND: See the comment at the beginning of this file.            
            height = CALIPSO_HEIGHT
            time = time[e1:e2,0]
            if elevation != None:
                elevation = elevation[e1:e2]
        else:
            fail("Assertion error: Unrecogized plot type `%s'" % what)
        
        # CloudSat products.
        if what == "cloudsat-reflec":
            # TODO: Mask _FillValue too.
            # TODO: Read factor, offset, _FillValue, title and units from the
            #       file.
            # FIXME: No masking is done for Height, Longitude and Latitude,
            #        or Profile_time,
            #        and the interpolation algorithm doesn't take NaN
            #        into consideration for these filed.
            data = reflec[e1:e2].astype(np.float32)/100
            np.place(data, data == -88.88, float("nan"))
            name = "Radar Reflectivity Factor (dBZe)"
            vmin = -40.0
            vmax = 30.0
        # CALIPSO profile products.
        elif what == "calipso532":
            data = backscat532[e1:e2]
            #np.place(data, data < 0, float("nan"))
            #data = data * (backscat532 > 0.0001)
            name = "Total Attenuated Backscatter 532nm (km$^{-1}$ sr$^{-1}$)"
            vmin = 0.001
            vmax = 1.0
        elif what == "calipso532p":
            data = backscat532p[e1:e2]
            name = "Perpendicular Attenuated Backscatter 532nm (km$^{-1}$ sr$^{-1}$)"
            vmin = 0.001
            vmax = 1.0
        elif what == "calipso1064":
            data = backscat1064[e1:e2]
            name = "Attenuated Backscatter 1064nm (km$^{-1}$ sr$^{-1}$)"
            vmin = 0.001
            vmax = 1.0
        elif what == "calipso-cratio":
            data = backscat1064[e1:e2] / backscat532[e1:e2]
            name = "Attenuated Color Ratio 1064nm/532nm"
            vmin = 0.0
            vmax = 2.0
        elif what == "calipso-dratio":
            data = backscat532p[e1:e2] / backscat532[e1:e2]    
            name = "Depolarization Ratio"
            vmin = 0.0
            vmax = 1.0
        # CALIPSO layer products.
        elif what == "calipso532-layer":
            data = backscat532_layer[e1:e2]
            name = "Integrated Attenuated Backscatter 532nm (sr$^{-1}$)"
            vmin = 0.001
            vmax = 1.0
        elif what == "calipso1064-layer":
            data = backscat1064_layer[e1:e2]
            name = "Integrated Attenuated Backscatter 1064nm (sr$^{-1}$)"
            vmin = 0.001
            vmax = 1.0
        elif what == "calipso-cratio-layer":
            data = cratio_layer[e1:e2]
            name = "Integrated Attenuated Total Color Ratio 1064nm/532nm"
            vmin = 0.0
            vmax = 2.0
        elif what == "calipso-dratio-layer":
            data = dratio_layer[e1:e2]
            name = "Integrated Volume Depolarization Ratio"
            vmin = 0.0
            vmax = 1.0
        elif what == "calipso-temperature-layer":
            data = temperature_layer[e1:e2] + 273.15
            name = "Midlayer Temperature (K)"
            vmin = -110
            vmax = 60
        else:
            fail("Assertion error: Unrecogized plot type `%s'" % what)
            
        if what.endswith("-layer"):
            product_name = "CALIPSO layer"
            nlayer = nlayer[e1:e2,0]
            basealt = basealt[e1:e2,:]
            topalt = topalt[e1:e2,:]
        else:
            data = data[:,::-1]

    except (KeyError, TypeError): fail("Required fields not in the data file")
    except IndexError: fail("%s: Invalid extent")

    ve1, ve2 = vextent

    minheight, maxheight = height.min(), height.max()
    if ve1 < minheight: ve1 = minheight
    if ve2 > maxheight: ve2 = maxheight
    if ve1 >= ve2: fail("Invalid vertical extent")
    if norm == None: norm = mpl.colors.Normalize(vmin, vmax)

    #
    # Core data processing and plotting.
    #
    resolution = int(get_axes_bounds(fig, axes)[3]*fig.get_dpi())
    if what.endswith("-layer"):     # Layer products.
        data = cctk.layermap(data, nlayer, basealt, topalt,
                             (ve1*0.001, ve2*0.001, resolution), float("nan"))
    else:                           # Profile products.
        if height.ndim == 1:
            Y, X = np.meshgrid(height, np.arange(0, e2-e1, dtype=np.float32))
        else:
            Y, X = np.meshgrid(height[0,:],
                               np.arange(0, e2-e1, dtype=np.float32))
            Y = height
        if radius == None: radius = int(PROFILE_BINHEIGHT*resolution/(ve2-ve1))
        X = X.astype(np.float32)
        Y = Y.astype(np.float32)
        data = cctk.interpolate2d(data, X, Y, (0, e2-e1, e2-e1),
                             (ve1, ve2, resolution), float("nan"), 0, radius)

    # Plot data.
    data = np.ma.masked_invalid(data)
    im = axes.imshow(data.T, origin="lower",
                     extent=(0, e2-e1, ve1*0.001, ve2*0.001),
                     interpolation="nearest", cmap=colormap, norm=norm)
    axes.set_aspect("auto")

    if elevation != None and opts.drawelev :
        line = mpl.lines.Line2D(np.arange(0, e2-e1), elevation,
                                color=opts.elevcolor, lw=opts.elevlw)
        axes.add_line(line)
    
    
    td = time2dt(time[-1]) - time2dt(time[0])
    nseconds = td.days*86400 + td.seconds
    if nseconds == 0: return
    x, y, width, height = get_axes_bounds(fig, axes)
    width = height/(aspect/(nseconds*ATRAIN_SPEED)*(ve2-ve1)*0.001)
    expand_axes(fig, axes, width, height, padding=opts.padding)
    figw, figh = fig.get_size_inches()
    #nlocs = int(width*1.5)
    
    # Time axis.
    axes.set_xlabel("Time (UTC)")
    axes.xaxis.set_minor_locator(TimeMinorLocator())
    axes.xaxis.set_major_locator(TimeLocator(width/(opts.fontsize/72.0*5), time, time2dt))
    axes.xaxis.set_major_formatter(TimeFormatter(time, time2dt))
    
    for line in axes.xaxis.get_ticklines() + axes.xaxis.get_minorticklines():
        line.set_marker(mpl.lines.TICKDOWN)

    for label in axes.xaxis.get_ticklabels():
        label.set_y(-0.1/figh)

    # Height axis.
    axes.set_ylabel("Altitude (km)")
    
    majorticksbases = np.array([0.5,   1,   2, 5])
    minorticksbases = np.array([0.1, 0.2, 0.5, 1])
    height_per_tick = (ve2-ve1)*0.001/(height/(opts.fontsize*2/72.0))
    i = np.argmin(np.abs(majorticksbases - height_per_tick))
    axes.yaxis.set_minor_locator(mpl.ticker.MultipleLocator(minorticksbases[i]))
    axes.yaxis.set_major_locator(mpl.ticker.MultipleLocator(majorticksbases[i]))

    for label in axes.yaxis.get_ticklabels():
        label.set_x(-0.1/figw)

    for line in axes.yaxis.get_ticklines()+axes.yaxis.get_minorticklines():
        line.set_marker(mpl.lines.TICKLEFT)

    # Hide ticks on the top and right-hand side.
    for tick in axes.xaxis.get_major_ticks() + \
                axes.yaxis.get_major_ticks() + \
                axes.xaxis.get_minor_ticks() + \
                axes.yaxis.get_minor_ticks():
        tick.tick1On = tick.label1On = True
        tick.tick2On = tick.label2On = False

    # Colorbar.
    cbaxes = fit_colorbar(fig, axes, space=opts.cbspacing, padding=opts.padding)
    cb = fig.colorbar(im, ax=axes, cax=cbaxes, orientation="vertical",
                      extend="both", ticks=ticks, norm=norm,
                      format=SciFormatter())
        
    cb.set_label(name)

    for label in cb.ax.get_yticklabels():
        label.set_fontsize(opts.cbfontsize)

    # Longitude/latitude.
    setup_lonlat_axes(fig, axes, lon, lat)


    title = "%s %s/%s" % (product_name,
                          time2dt(time[0]).strftime("%Y-%m-%dT%H:%M:%SZ"),
                          time2dt(time[-1]).strftime("%Y-%m-%dT%H:%M:%SZ"))
    figure_title(fig, opts, title)


def plot_orbit(fnames, niofiles, nioeosfiles, fig, axes,
    hextent=HorizontalExtent(),
    band=1, band_mode=BAND_MODE_RADIANCE, proj='cyl', proj_opts=ProjOpts(),
    clipped=False,
    colormap=None, norm=None,
    ticks=None, radius=None, opts=PlotOpts()):
    """Draws a map plot of a CloudSat and CALIPSO trajectories and MODIS swath.
    
    Arguments:
        niofiles    -- a list of NIO files
        fig         -- matplotlib Figure instance
        axes        -- matplotlib Axes instance
        hextent     -- an instance of HorizontalExtent
        band        -- band to plot (integer or 13.5 or 14.5 for high bands)
        band_mode   -- any of BAND_MODE_* constants
        proj        -- Basemap projection name
        clipped     -- clip map to MODIS swath
        colormap    -- matplotlib Colormap instance
        norm        -- matplotlib Normalize instance
        ticks       -- a list of ticks to be drawn on colorbar
    """
    
    info("Plotting orbit")
    
    titlea = []
    
    along_track_ext = (0, -1)
    across_track_ext = (0, -1)
    if hextent.extent_type == HorizontalExtent.TYPE_ALONG_TRACK:
        along_track_ext = hextent.along_track
    elif hextent.extent_type == HorizontalExtent.TYPE_ALONG_TRACK_ACROSS_TRACK:
        along_track_ext = hextent.along_track
        across_track_ext = hextent.across_track
    elif hextent.extent_type == HorizontalExtent.TYPE_LON_LAT:
        pass # Handled later.
    elif hextent.extent_type == HorizontalExtent.TYPE_NONE:
        pass
    else: fail("Extent type not supported by swath plots")
    
    # Search for a MODIS data file.
    modis_swath = None
    for fname, niofile, nioeosfile in zip(fnames, niofiles, nioeosfiles):
        info("Attempting to read MODIS swath from %s" % fname)
        modis_swath = read_modis_swath(niofile, nioeosfile, band, band_mode,
                                       along_track_ext, across_track_ext)
        if modis_swath != None: break

    if modis_swath != None and clipped:
        minorticks_base = 10000
        majorticks_base = 60000
        minorparallels = np.arange(-90, 90, 1)
        majorparallels = np.arange(-90, 90, 5)
        minormeridians = np.arange(-180, 180, 1)
        majormeridians = np.arange(-180, 180, 5)
        lon_0 = np.average(modis_swath.lon) # Central meridian.
        lat_0 = np.average(modis_swath.lat) # Central latitude.
        lon_min, lat_min = modis_swath.lon.min(), modis_swath.lat.min()
        lon_max, lat_max = modis_swath.lon.max(), modis_swath.lat.max()
        
    else:
        minorticks_base = 60000
        majorticks_base = 300000
        minorparallels = np.arange(-90, 90, 10)
        majorparallels = np.arange(-90, 90, 30)
        minormeridians = np.arange(-180, 180, 10)
        majormeridians = np.arange(-180, 180, 30)
        lon_0 = 0 # Central meridian.
        lat_0 = 0 # Central latitude.

        if proj == "merc":
            lon_min, lon_max = -180, 180
            lat_min, lat_max = -80, 80
        elif proj == "tmerc":
            lon_min, lon_max = -80, 80
            lat_min, lat_max = -90, 90
            # FIXME: matplotlib is unhappy about these settings,
            #        but they should be all right
        elif proj == "npstere":
            lon_min, lon_max = -180, 180
            lat_min, lat_max = 60, 90
        elif proj == "spstere":
            lon_min, lon_max = -180, 180
            lat_min, lat_max = -90, -60
        else:
            lon_min, lon_max = -180, 180
            lat_min, lat_max = -90, 90

    if proj == "npstere":
        minorparallels = np.arange(0, 80, 5)
        majorparallels = np.arange(0, 80, 10)
        minormeridians = np.arange(-180, 180, 10)
        majormeridians = np.arange(-180, 180, 30)
    if proj == "spstere":
        minorparallels = np.arange(-80, 0, 5)
        majorparallels = np.arange(-80, 0, 10)
        minormeridians = np.arange(-180, 180, 10)
        majormeridians = np.arange(-180, 180, 30)

    if opts.parallelsbase > 0:
        majorparallels = np.arange(-90, 90, opts.parallelsbase)
        if opts.nminorparallels > 0:
            minorparallels = np.arange(-90, 90,
                                       opts.parallelsbase/opts.nminorparallels)
        else:
            minorparallels = np.arange(-90, 90, opts.parallelsbase/2.0)

    if opts.meridiansbase > 0:
        majormeridians = np.arange(-180, 180, opts.meridiansbase)
        if opts.nminormeridians > 0:
            minormeridians = np.arange(-180, 180,
                                       opts.meridiansbase/opts.nminormeridians)
        else:
            minormeridians = np.arange(-180, 180, opts.meridiansbase/2.0)

    if hextent.extent_type == HorizontalExtent.TYPE_LON_LAT:
        # Determine projection parameters from the horizontal extent given.
        lon_0 = np.average(hextent.lon)
        lat_0 = np.average(hextent.lat)
        lon_min, lat_min = min(hextent.lon), min(hextent.lat)
        lon_max, lat_max = max(hextent.lon), max(hextent.lat)

    if opts.trajticks > 0:
        majorticks_base = opts.trajticks * 1000
    
    if opts.trajnminorticks == 0:
        minorticks_base = 0
    elif opts.trajnminorticks > 0:
        minorticks_base = int(majorticks_base / opts.trajnminorticks)

    if proj.startswith("sp"):
        boundinglat = min(lat_max, 0.0)
        lon_0 = 180.0
        lat_0 = -90.0
    elif proj.startswith("np"):
        boundinglat = max(lat_min, 0.0)
        lon_0 = 0.0
        lat_0 = 90.0
    else:
        boundinglat = 0.0

    if proj_opts.boundinglat != None:
        boundinglat = proj_opts.boundinglat
    
    if proj_opts.lon_0 != None:
        lon_0 = proj_opts.lon_0
    
    if proj_opts.lat_0 != None:
        lat_0 = proj_opts.lat_0

    info("Initialising basemap:")
    info("  lon_0=%.1f, lat_0=%.1f" % (lon_0, lat_0))
    info("  lon_min=%.1f, lon_max=%.1f, lat_min=%.1f, lat_max=%.1f"
         % (lon_min, lon_max, lat_min, lat_max))
    info("  boundinglat=%.1f" % boundinglat)

    # Plot map.
    m = basemap.Basemap(projection=proj, lon_0=lon_0, lat_0=lat_0,
                        llcrnrlon=lon_min, llcrnrlat=lat_min,
                        urcrnrlon=lon_max, urcrnrlat=lat_max,
                        boundinglat=boundinglat,
                        resolution=opts.mapres, ax=axes,
                        lon_1=proj_opts.lon_1, lat_1=proj_opts.lat_1,
                        lon_2=proj_opts.lon_2, lat_2=proj_opts.lat_2,
                        lat_ts=proj_opts.lat_ts)

    x, y, width, height = get_axes_bounds(fig, axes)
    expand_axes(fig, axes, height/m.aspect, height, padding=opts.padding)

    if proj == "tmerc":
        def pick(x, center, radius, modulus):
            dx = x - center
            return x[np.abs(dx - np.round(dx/modulus)*modulus) < radius]
        minormeridians = pick(minormeridians, lon_0, 90.0, 360.0)
        majormeridians = pick(majormeridians, lon_0, 90.0, 360.0)

    if opts.drawcoastlines:
        m.drawcoastlines(linewidth=opts.coastlineslw, color=opts.coastlinescolor)
    if opts.drawcountries:
        m.drawcountries(linewidth=opts.countrieslw, color=opts.countriescolor)
    if opts.drawlsmask:
        m.drawlsmask(opts.landcolor, opts.watercolor, lakes=opts.drawlakes)
    if opts.drawminorparallels:
        m.drawparallels(minorparallels, dashes=[],
                        linewidth=opts.minorparallelslw,
                        color=opts.minorparallelscolor)
    if opts.drawparallels:
        m.drawparallels(majorparallels, dashes=[],
                        linewidth=opts.majorparallelslw,
                        color=opts.majorparallelscolor,
                        labels=[1, 0, 0, 0])
    if opts.drawminormeridians:
        m.drawmeridians(minormeridians, dashes=[],
                         linewidth=opts.minormeridianslw,
                         color=opts.minormeridianscolor)
    if opts.drawmeridians:
        m.drawmeridians(majormeridians, dashes=[],
                        linewidth=opts.majormeridianslw,
                        color=opts.majormeridianscolor,
                        labels=[0, 0, 0, 1])
    
    # Plot swath.
    if modis_swath != None:
        info("Plotting swath")
        plot_swath(modis_swath, m, fig, axes, colormap=colormap, norm=norm,
                   ticks=ticks, radius=radius, opts=opts)
        titlea += ["MODIS Swath"]

    info("Plotting trajectories")

    # Plot trajectories.
    j = 0
    for i, (niofile, nioeosfile) in enumerate(zip(niofiles, nioeosfiles)):   
        if nioeosfile != None and \
           nioeosfile.variables.has_key("Longitude_MODIS_SWATH_Type_L1B"):
            continue
        hit = False
        try: # Try CALIPSO names.
            time = niofile.variables["Profile_UTC_Time"][:, 0]
            lon = niofile.variables["Longitude"][:, 0]
            lat = niofile.variables["Latitude"][:, 0]
            time2dt = calipso_time2dt
            satellite = "CALIPSO"
            hit = True
        except (KeyError, IndexError): pass
        try: # Try CloudSat names.
            time = nioeosfile.variables["Profile_time_2B_GEOPROF"][:]
            lon = nioeosfile.variables["Longitude_2B_GEOPROF"][:]
            lat = nioeosfile.variables["Latitude_2B_GEOPROF"][:]
            start_time = nioeosfile.attributes["start_time_2B_GEOPROF"]
            start_time_dt = dt.datetime.strptime(start_time, "%Y%m%d%H%M%S")
            time2dt = lambda t: cloudsat_time2dt(t, start_time_dt)
            satellite = "CloudSat"
            hit = True
        except (AttributeError, KeyError, IndexError): pass
        
        if hit:
            lw = opts.trajlws[j % len(opts.trajlws)]
            color = opts.trajcolors[j % len(opts.trajcolors)]
            mask = plot_trajectory(fig, axes, m, lon, lat, time,
                time2dt, minorticks_base,
                majorticks_base, lw=lw, color=color)
            time_min = time_max = None
            for i in range(0, len(mask)):
                if mask[i]:
                    time_min = time2dt(time[i])
                    break
            for i in reversed(range(0, len(mask))):
                if mask[i]:
                    time_max = time2dt(time[i])
                    break
            if time_min < time_max:
                titlea += ["%s Trajectory %s/%s" % \
                           (satellite,
                            time_min.strftime("%Y-%m-%dT%H:%M:%SZ"),
                            time_max.strftime("%Y-%m-%dT%H:%M:%SZ"))]
            j = j+1
        else: warn("%s: Unrecognized file, skipping" % fnames[i])

    # Plot title.
    title = ", ".join(titlea)
    figure_title(fig, opts, title)
    

def plot_trajectory(fig, axes, m, lon, lat, time, time2dt,
    minorticks_base, majorticks_base, lw=1.0, color="#000000"):

    #
    # Helper functions.
    #
    def drawtick(i, ticksize, tickwidth, text=None):
        ticksize_in = ticksize/72.0
        w_in, h_in = fig.get_size_inches()

        def t(x, y):
            return fig.transFigure.inverted().transform(
                axes.transData.transform((x, y)))*(w_in, h_in)

        if i == 0:
            dx, dy = t(X[1], Y[1]) - t(X[0], Y[0])
        elif i == nray-1:
            dx, dy = t(X[i], Y[i-1]) - t(X[i], Y[i-1])
        else:
            dx, dy = t(X[i+1], Y[i+1]) - t(X[i-1], Y[i-1])
        
        l = sqrt(dx**2 + dy**2)
        if (l == 0): v = np.array((ticksize_in, 0))
        else: v = np.array((dy, -dx))/l

        x, y = t(X[i], Y[i])

        trans = mpl.transforms.Affine2D().scale(1.0/w_in, 1.0/h_in) + \
            fig.transFigure
            
        line = mpl.lines.Line2D((x, x + v[0]*ticksize_in),
                                (y, y + v[1]*ticksize_in), transform=trans,
                                color="black", lw=tickwidth)
        axes.add_line(line)

        if text != None:
            doty = np.dot(v, (0, 1))
            dotx = np.dot(v, (1, 0))
            if dotx < -0.3: halign = "right"
            elif dotx > 0.3: halign = "left"
            else: halign = "center"
            
            if doty < -0.3: valign = "top"
            elif doty > 0.3: valign = "bottom"
            else: valign = "center"

            axes.text(x + v[0]*(ticksize_in*2),
                      y + v[1]*(ticksize_in*2),
                      text,
                      horizontalalignment=halign,
                      verticalalignment=valign,
                      transform=trans)
    
    nray = len(time)
    time_from = time2dt(time[0])
    time_to = time2dt(time[-1])
    d = time_to - time_from
    # Delta time in milliseconds.
    time_delta = d.days*86400000 + d.seconds*1000 + d.microseconds/1000
    del d

    X, Y = m(lon, lat)
    xmin = min(m.llcrnrx, m.urcrnrx)
    xmax = max(m.llcrnrx, m.urcrnrx)
    ymin = min(m.llcrnry, m.urcrnry)
    ymax = max(m.llcrnry, m.urcrnry)    
    mask = (X > xmin) & (X < xmax) & (Y > ymin) & (Y < ymax)

    # WORKAROUND: This is a pretty nasty workaround. Because basemap
    # translates points lying on the other hemisphere to our viewport,
    # we have to check whether they are mapped back to the original point
    # under inverse transformation.
    lon_inv, lat_inv = m(X, Y, inverse=True)
    mask = mask & (abs(lon-lon_inv) + abs(lat-lat_inv) < 0.001)

    if not mask.max(): return mask # Nothing to plot.

    # Plot trajectory ticks.
    ratio = 1.0*nray/time_delta if time_delta != 0 else 0
    offset = long(ratio*(-time_from.microsecond/1000.0-time_from.second*1000+100))
    if offset == 0: offset = -1 # For safety reasons.
    minorticks = np.empty(0, np.long)
    majorticks = np.empty(0, np.long)
    if minorticks_base > 0:
        minorticks = np.arange(offset,nray-1,ratio*minorticks_base).astype(long)
    if majorticks_base > 0:
        majorticks = np.arange(offset,nray-1,ratio*majorticks_base).astype(long)

    # We need to fix the aspect ratio before drawing ticks.
    axes.apply_aspect()

    for i in minorticks:
        if i < 0 or not mask[i]: continue
        drawtick(i, 1.0, lw*0.5)

    for i in majorticks:
        if i < 0 or not mask[i]: continue
        timestr = time2dt(time[i]).strftime("%H:%M:%S")
        drawtick(i, 1.5, lw, timestr)

    trajectory = mpl.lines.Line2D(X[mask], Y[mask], color=color, lw=lw)
    axes.add_line(trajectory)
    
    return mask
    
#    indices = np.flatnonzero(abs(X-np.roll(X, -1)) + \
#              abs(Y-np.roll(Y, -1)) > 1) + 1
#    Xsplit = np.array_split(X, indices)
#    Ysplit = np.array_split(Y, indices)
#    for i in range(len(indices)):
#        m.plot(Xsplit[i], Ysplit[i], color=color, lw=lw)


def read_modis_swath(niofile, nioeosfile, band, band_mode,
                     along_track_ext=(0,-1), across_track_ext=(0,-1)):

    if nioeosfile == None or \
       not nioeosfile.variables.has_key("Longitude_MODIS_SWATH_Type_L1B"):
        return None # This is not a valid MODIS file.

    try:
        lon = niofile.variables["Longitude"]
        lat = niofile.variables["Latitude"]
    except KeyError, err: 
        return None

    data = None
    if band in (1, 2):
        data = niofile.variables.get("EV_250_RefSB", data)
        data = niofile.variables.get("EV_250_Aggr500_RefSB", data)
        data = niofile.variables.get("EV_250_Aggr1km_RefSB", data)
        band_offset = -1
    elif band in (3, 4, 5, 6, 7):
        data = niofile.variables.get("EV_500_RefSB", data)
        data = niofile.variables.get("EV_500_Aggr1km", data)
        band_offset = -3
    elif band in range(8, 20) or band in (13.5, 14.5):
        data = niofile.variables.get("EV_1KM_RefSB", data)
        if band <= 13: band_offset = -8
        elif band == 13.5: band_offset = -7
        elif band == 14.0: band_offset = -7
        else: band_offset = -6
    elif band in range(20, 26):
        data = niofile.variables.get("EV_1KM_Emissive", data)
        band_offset = -20
    # TODO: Add support for band 26.
    elif band == 26: fail("Band 26 is not supported")
    elif band in range(27, 37):
        data = niofile.variables.get("EV_1KM_Emissive", data)
        band_offset = -21

    band_index = band + band_offset

    if data == None or data.shape[0] <= band_index:
        fail("%d: Band not present in the data file" % band)

    # Determine parameters for dimension mapping.
    nscan_ndet_name = stripstr(data.dimensions[1], "_MODIS_SWATH_Type_L1B")
    nfram_nsam_name = stripstr(data.dimensions[2], "_MODIS_SWATH_Type_L1B")

    geo_nscan_ndet_name = stripstr(lon.dimensions[0], "_MODIS_SWATH_Type_L1B")
    geo_nfram_nsam_name = stripstr(lon.dimensions[1], "_MODIS_SWATH_Type_L1B")

    try:
        off1, inc1 = nioeosfile.attributes[geo_nscan_ndet_name + \
            "_to_" + nscan_ndet_name + \
            "_mapping_offset_and_increment_MODIS_SWATH_Type_L1B"]

        off2, inc2 = nioeosfile.attributes[geo_nfram_nsam_name + \
            "_to_" + nfram_nsam_name + \
            "_mapping_offset_and_increment_MODIS_SWATH_Type_L1B"]
    except KeyError, err: fail("%s: Attribute not found" % err)

    if band_mode == BAND_MODE_REFLECTANCE and band >= 20 and band != 26:
        fail("Invalid band")

    if band_mode == BAND_MODE_REFLECTANCE:
        try:
            si_scale = data.attributes["reflectance_scales"][band_index]
            si_offset = data.attributes["reflectance_offsets"][band_index]
        except KeyError: fail("Reflectance parameters not present")
    elif band_mode == BAND_MODE_RADIANCE:
        try:
            si_scale = data.attributes["radiance_scales"][band_index]
            si_offset = data.attributes["radiance_offsets"][band_index]
        except KeyError: fail("Radiance parameters not present")
    else: fail("Assertion error: Invalid ref/rad switch")

    nscan_ndet = data.shape[1]
    nfram_nsam = data.shape[2]

    e1, e2 = along_track_ext
    e3, e4 = across_track_ext     

    e1 = norm_index(e1, 0, nscan_ndet)
    e2 = norm_index(e2, 0, nscan_ndet)
    e3 = norm_index(e3, 0, nfram_nsam)
    e4 = norm_index(e4, 0, nfram_nsam)

    if e1 >= e2 or e3 >= e4: return None

    # Perform dimension mapping on lon/lat.
    lon = cctk.dimmap2d(lon[:,:], off1, inc1, off2, inc2, 360.0)[e1:e2, e3:e4]
    lat = cctk.dimmap2d(lat[:,:], off1, inc1, off2, inc2, 180.0)[e1:e2, e3:e4]
    lon = (lon + 180.0) % 360.0 - 180.0
    lat = (lat + 90.0) % 180.0 - 90.0

    # Choose band and crop data.
    data = data[band_index, e1:e2, e3:e4].astype(np.float32)
    # Set invalid data elements to NaN.
    np.place(data, data < 0.0, float("nan"))
    # Peform dimension mapping.
    data = np.float32(si_scale) * (data - np.float32(si_offset))
    # Radiance to temperature conversion.
    if band_mode == BAND_MODE_RADIANCE:
        data = radiance2temp(data, modis_band_wavelength(band) * 1E-9)
        name = "Band %2.1f Black Body Temperature (K)" % band
    elif band_mode == BAND_MODE_REFLECTANCE:
        data *= 100 # In per cent.
        name = "Band %2.1f Albedo (%%)" % band

    swath = Swath()
    swath.lon = lon
    swath.lat = lat
    swath.data = data
    swath.name = name
    return swath
    

def plot_swath(swath, m, fig, axes, colormap=None, norm=None, ticks=None,
               radius=None, name=None, opts=PlotOpts()):

    global EV_DATAPOINT_SIZE

    # lon/lat to X/Y conversion.
    X, Y = m(swath.lon, swath.lat)
    if X.dtype != np.float32: X = np.asarray(X, dtype=np.float32)
    if Y.dtype != np.float32: Y = np.asarray(Y, dtype=np.float32)

    # Interpolate data on X/Y grid.
    x, y, width, height = get_axes_bounds(fig, axes)
    nx = int(width * fig.get_dpi())
    ny = int(height * fig.get_dpi())
    if radius == None:
        if m.projection == "cyl":
            xfactor = 20037508.34/180.0
            yfactor = 10018754.17/90.0
        else:
            xfactor = yfactor = 1.0
                   
        radius_x = int(EV_DATAPOINT_SIZE/((m.urcrnrx-m.llcrnrx)*xfactor)*nx+0.5)
        radius_y = int(EV_DATAPOINT_SIZE/((m.urcrnry-m.llcrnry)*yfactor)*ny+0.5)
        info("Interpolation radius: rx=%d, ry=%d" % (radius_x, radius_y))
    else:
        radius_x = radius_y = radius
    data = cctk.interpolate2d(swath.data, X, Y, (m.llcrnrx, m.urcrnrx, nx),
                              (m.llcrnry, m.urcrnry, ny), float("nan"),
                              radius_x, radius_y)
    del X, Y

    # Mask invalid values.
    data = np.ma.masked_invalid(data)

    # Plotting.
    im = m.imshow(data.T, cmap=colormap, norm=norm, interpolation="nearest")

    cbaxes = fit_colorbar(fig, axes, space=opts.cbspacing, padding=opts.padding)
    cb = fig.colorbar(im, ax=axes, cax=cbaxes, orientation="vertical",
                      extend="both", norm=norm, ticks=ticks)
    cb.set_label(swath.name)

    for label in cb.ax.get_yticklabels():
        label.set_fontsize(opts.cbfontsize)


#
# The program starts here.
#
def main(argv):
    global CCPLOT_CMAP_PATH    
    CCPLOT_CMAP_PATH = os.getenv("CCPLOT_CMAP_PATH", CCPLOT_CMAP_PATH)

    opts = parse_options(argv)

    # Open each file as HDF and HDF-EOS if possible.
    niofiles = []
    nioeosfiles = []
    for fname in opts.fnames:
        try: niofile = Nio.open_file(fname, "r", format="hdf")
        except Nio.NIOError, err: fail("%s: %s" % (fname, err))
        niofiles.append(niofile)

        nioeosfile = None
        if niofile.attributes.has_key("HDFEOSVersion"):
            try:
                nioeosfile = Nio.open_file(fname, "r", format="hdfeos")
            except Nio.NIOError, err: fail("%s: %s" % (fname, err))
        nioeosfiles.append(nioeosfile)
    
    if opts.print_info_only:
        # Print information about the file and exit.
        if nioeosfiles[0] == None: print_info(niofiles[0])
        else: print_info(nioeosfiles[0])
        sys.exit(0)

    mpl.rcParams["font.size"] = opts.plot_opts.fontsize

    fig = plt.figure(figsize=(1, 1), dpi=opts.dpi)
    axes = new_axes(fig, opts.plot_opts.padding,
                         opts.plot_opts.padding,
                         0,
                         opts.plot_opts.plotheight,
                         padding=opts.plot_opts.padding)
   
    # Determine colormap, norm and ticks.
    colormap = mpl.cm.Greys
    colormap.set_bad("k", 0.0)
    norm = None
    ticks = None
    if opts.cmapfname != None:
        (colormap, norm, ticks) = loadcolormap(opts.cmapfname, "colormap")

    # Main switch.
    if opts.plot_type == "cloudsat-reflec":
        if len(nioeosfiles) != 1 or nioeosfiles[0] == None:
            fail("Single HDF-EOS file expected")
        plot_profile(opts.plot_type, opts.fnames[0], nioeosfiles[0], fig, axes,
                  hextent=opts.hextent,
                  vextent=opts.vextent,
                  aspect=opts.aspect,
                  colormap=colormap,
                  norm=norm,
                  ticks=ticks,
                  radius=opts.radius,
                  opts=opts.plot_opts)
                  
    elif opts.plot_type == "calipso532" or \
         opts.plot_type == "calipso532p" or \
         opts.plot_type == "calipso1064" or \
         opts.plot_type == "calipso-cratio" or \
         opts.plot_type == "calipso-dratio":
        if len(niofiles) != 1: usage()
        
        plot_profile(opts.plot_type, opts.fnames[0], niofiles[0], fig, axes,
                     hextent=opts.hextent,
                     vextent=opts.vextent,
                     aspect=opts.aspect,
                     colormap=colormap,
                     norm=norm,
                     ticks=ticks,
                     radius=opts.radius,
                     opts=opts.plot_opts)
                     
    elif opts.plot_type == "calipso532-layer" or \
         opts.plot_type == "calipso1064-layer" or \
         opts.plot_type == "calipso-cratio-layer" or \
         opts.plot_type == "calipso-dratio-layer" or \
         opts.plot_type == "calipso-temperature-layer":
         
        if len(niofiles) != 1: fail("Single HDF file expected")
        plot_profile(opts.plot_type, opts.fnames[0], niofiles[0], fig, axes,
                     hextent=opts.hextent,
                     vextent=opts.vextent,
                     aspect=opts.aspect,
                     colormap=colormap,
                     norm=norm,
                     ticks=ticks,
                     radius=opts.radius,
                     opts=opts.plot_opts)
                     
    elif opts.plot_type == "orbit":
        plot_orbit(opts.fnames, niofiles, nioeosfiles, fig, axes,
                   band=opts.modis_band,
                   band_mode=opts.modis_band_mode,
                   hextent=opts.hextent,
                   proj=opts.projection,
                   colormap=colormap,
                   norm=norm,
                   ticks=ticks,
                   radius=opts.radius,
                   proj_opts = opts.proj_opts,
                   opts=opts.plot_opts)
                   
    elif opts.plot_type == "orbit-clipped":
        plot_orbit(opts.fnames, niofiles, nioeosfiles, fig, axes,
                   band=opts.modis_band,
                   band_mode=opts.modis_band_mode,
                   hextent=opts.hextent,
                   proj=opts.projection,
                   colormap=colormap,
                   norm=norm,
                   ticks=ticks,
                   clipped=True,
                   radius=opts.radius,
                   proj_opts = opts.proj_opts,
                   opts=opts.plot_opts)
                   
    else:
        fail("Invalid plot type `%s'" % opts.plot_type)
    
    #report_memory()

    figw_px, figh_px = fig.get_size_inches()*opts.dpi
    if figw_px >= 32768 or figh_px >= 32768:
        fail("Figure size exceeds 32767 pixels, please specify a smaller region")

    info("Saving plot")

    try: plt.savefig(opts.outfname, dpi=opts.dpi)
    except IOError, err: fail("Write error: %s" % err)

    #report_memory()
    
    
if __name__ == "__main__":
    try:
        main(sys.argv)
    except MemoryError:
        fail("Insufficient memory")
    except np.linalg.linalg.LinAlgError, err:
        fail("Linear algebra error: %s" % err)

